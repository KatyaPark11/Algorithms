namespace Algorithms
{
    /// <summary>
    /// Класс, реализующий алгоритмы, для которых не требуется много методов.
    /// </summary>
    public static class SimpleAlgorithms
    {
        /// <summary>
        /// Метод, реализующий сортировку пузырьком.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        public static void BubbleSort(int[] array)
        {
            // Пробегаемся по массиву n раз, где n - размер массива.
            for (int i = 0; i < array.Length; i++)
                // Пробегаемся по массиву n - 1 раз, где n - размер массива.
                for (int j = 1; j < array.Length; j++)
                    // Сравниваем предыдущий элемент с текущим.
                    if (array[j - 1] > array[j])
                        // Если предыдущий элемент больше текущего, то меняем их местами.
                        (array[j - 1], array[j]) = (array[j], array[j - 1]);
        }

        /// <summary>
        /// Метод, реализующий сортировку вставками.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        public static void InsertSort(int[] array)
        {
            // Пробегаемся по массиву n - 1 раз, где n - размер массива.
            for (int i = 1; i < array.Length; i++)
            {
                // Устанавливаем индекс первого элемента неотсортированной части в качестве j.
                int j = i;
                // Пока элемент не стоит на своём месте в отсортированной части массива, перемещаем его.
                while (j > 0 && array[j - 1] > array[j])
                {
                    // Меняем местами предыдущий и текущий элементы.
                    (array[j - 1], array[j]) = (array[j], array[j - 1]);
                    // Декрементируем индекс текущего элемента.
                    j--;
                }
            }
        }

        /// <summary>
        /// Метод, реализующий сортировку выбором.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        public static void SelectSort(int[] array)
        {
            // Пробегаемся по массиву n раз, где n - размер массива.
            for (int i = 0; i < array.Length; i++)
            {
                // Устанавливаем индекс первого элемента неотсортированной части в качестве minIndex.
                int minIndex = i;

                // Пробегаемся по массиву n - i - 1 раз, где n - i - 1 - размер неотсортированной части массива. 
                for (int j = i + 1; j < array.Length; j++)
                    // Сравниваем текущий элемент с текущим минимальным.
                    if (array[j] < array[minIndex])
                        // Если текущий элемент меньше текущего минимального, то устанавливаем его в качестве минимального.
                        minIndex = j;

                // Проверяем, поменялся ли индекс минимального элемента.
                if (minIndex != i)
                    // Если индекс поменялся, то меняем минимальный элемент с первым элементом неотсортированной части.
                    (array[minIndex], array[i]) = (array[i], array[minIndex]);
            }
        }

        /// <summary>
        /// Метод, реализующий шейкерную сортировку.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        public static void ShakerSort(int[] array)
        {
            // Устанавливаем первый элемент в качестве левого указателя.
            int left = 0;
            // Устанавливаем последний элемент в качестве правого указателя.
            int right = array.Length - 1;

            // Сортируем элементы до тех пор, пока не дойдём до центра массива.
            while (left < right)
            {
                // Пробегаемся по массиву от левого до правого указателя.
                for (int i = left; i < right; i++)
                    // Сравниваем текущий элемент со следующим.
                    if (array[i] > array[i + 1])
                        // Если текущий элемент больше следующего, то меняем их местами.
                        (array[i], array[i + 1]) = (array[i + 1], array[i]);
                // Декрементируем правый указатель.
                right--;

                // Пробегаемся по массиву от правого до левого указателя.
                for (int i = right; i > left; i--)
                    // Сравниваем предыдущий элемент с текущим.
                    if (array[i - 1] > array[i])
                        // Если предыдущий элемент больше текущего, то меняем их местами.
                        (array[i - 1], array[i]) = (array[i], array[i - 1]);
                // Инкрементируем левый указатель.
                left++;
            }
        }

        /// <summary>
        /// Метод, реализующий сортировку Шелла.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        public static void ShellSort(int[] array)
        {
            // Устанавливаем половину длины массива в качестве шага.
            int step = array.Length / 2;

            // Пока шаг больше нуля, выполняем сортировку.
            while (step > 0)
            {
                // Пробегаемся по массиву n - step раз, где n - длина массива.
                for (int i = step; i < array.Length; i++)
                {
                    // Устанавливаем индекс первого элемента неотсортированной части подмассива в качестве j.
                    int j = i;

                    // Пока элемент не стоит на своём месте в отсортированной части подмассива, перемещаем его.
                    while (j >= step && array[j - step] > array[j])
                    {
                        // Меняем местами предыдущий и текущий элементы подмассива.
                        (array[j - step], array[j]) = (array[j], array[j - step]);
                        // Декрементируем индекс текущего элемента подмассива.
                        j -= step;
                    }
                }

                // Уменьшаем шаг вдвое.
                step /= 2;
            }
        }

        /// <summary>
        /// Метод, реализующий бинарный поиск.
        /// </summary>
        /// <param name="array">Массив для поиска элемента.</param>
        /// <param name="target">Искомый элемент.</param>
        /// <returns>Индекс искомого элемента. В случае отсутствия элемента в массиве, возвращается -1.</returns>
        public static int BinarySearch(int[] array, int target)
        {
            // Устанавливаем первый элемент в качестве левой границы.
            int left = 0;
            // Устанавливаем последний элемент в качестве правой границы.
            int right = array.Length - 1;

            // Продолжаем поиск до тех пор, пока границы не встретятся.
            while (left <= right)
            {
                // Устанавливаем индекс среднего элемента между левой и правой границами.
                int mid = left + (right - left) / 2;

                // Сравниваем средний элемент с искомым.
                if (array[mid] == target)
                    // Если средний элемент равен искомому, то возвращаем его индекс.
                    return mid;
                else if (array[mid] > target)
                    // Если средний элемент больше искомого, сужаем диапазон поиска до левой половины.
                    right = mid - 1;
                else
                    // Если средний элемент меньше искомого, сужаем диапазон поиска до левой половины.
                    left = mid + 1;
            }

            // Если элемент не был найден, возвращаем -1.
            return -1;
        }

        /// <summary>
        /// Метод, реализующий быструю сортировку.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        /// <param name="left">Левого указатель.</param>
        /// <param name="right">Правый указатель.</param>
        public static void QuickSort(int[] array, int left, int right)
        {
            // Сортируем элементы до тех пор, пока между левым и правым указателем не окажется меньше двух элементов.
            if (left < right)
            {
                // Устанавливаем опорный элемент на верное место.
                int pivotIndex = Partition(array, left, right);

                // Сортируем левую часть массива.
                QuickSort(array, left, pivotIndex - 1);
                // Сортируем правую часть массива.
                QuickSort(array, pivotIndex + 1, right);
            }
        }

        /// <summary>
        /// Метод, реализующий установку последнего (опорного) элемента подмассива на верное место.
        /// </summary>
        /// <param name="array">Массив для сортировки.</param>
        /// <param name="left">Левый указатель.</param>
        /// <param name="right">Правый указатель.</param>
        /// <returns>Обновлённый индекс опорного элемента.</returns>
        private static int Partition(int[] array, int left, int right)
        {
            // Устанавливаем последний элемент подмассива в качестве опорного элемента.
            int pivot = array[right];
            // Устанавливаем  индекс элемента перед левым указателем в качестве индекса, перед которым будут находиться элементы меньше опорного.
            int i = left - 1;

            // Пробегаемся по массиву от левого до правого указателя.
            for (int j = left; j < right; j++)
            {
                // Сравниваем текущий элемент с опорным.
                if (array[j] <= pivot)
                {
                    // Если текущий элемент нестрого меньше опорного, то:
                    // Инкрементируем индекс, перед которым будут находиться элементы меньше опорного.
                    i++;
                    // Меняем местами текущий элемент и элемент, перед которым будут находиться элементы меньше опорного.
                    (array[i], array[j]) = (array[j], array[i]);
                }
            }

            // Меняем местами опорный элемент с элементом, находящимся после всех элементов меньше него.
            (array[i + 1], array[right]) = (array[right], array[i + 1]);
            // Возвращаем обновлённый индекс опорного элемента.
            return i + 1;
        }
    }
}
