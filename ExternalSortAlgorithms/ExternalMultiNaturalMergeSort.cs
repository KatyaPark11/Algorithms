namespace Algorithms.ExternalSortAlgorithms
{
    /// <summary>
    /// Класс, реализующий внешнюю сортировку многопутевым естественным слиянием.
    /// </summary>
    public class ExternalMultiNaturalMergeSort
    {
        /// <summary>
        /// Метод, реализующий внешнюю сортировку многопутевым естественным слиянием.
        /// </summary>
        /// <param name="inputPath">Путь к файлу с массивом для сортировки.</param>
        public static void Sort(string inputPath, int threadsNum)
        {
            // Проверяем, допустимо ли введённое количество путей.
            if (threadsNum > 25)
            {
                // Выводим сообщение об ошибке.
                Console.WriteLine("Указано слишком большое число путей. Сортировка не выполнена.");
                // Выходим из метода.
                return;
            }
            // Копируем файл с массивом для сортировки в файл с будущим отсортированным массивом.
            File.Copy(inputPath, "fileA.txt", true);
            // Устанавливаем список серий (отсортированных подмассивов).
            List<int> series = [];
            // Пока после разделения на файлы не останется одна серия, выполняем сортировку.
            while (true)
            {
                series.Clear();
                // Разделяем файл с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
                SplitToFiles(series, threadsNum);
                // Если осталась одна серия, прекращаем сортировку.
                if (series.Count == 1) break;
                // Сливаем временные файлы в файл с будущим отсортированным массивом.
                MergePairs(series, threadsNum, out StreamReader[] readers);
                // Пробегаемся по считывателям из временных файлов.
                foreach (var reader in readers)
                    // Закрываем поток.
                    reader.Dispose();
            }

            // Пробегаемся от нуля до числа путей.
            for (int i = 0; i < threadsNum; i++)
                // Удаляем текущий временный файл.
                File.Delete($"file{(char)('B' + i)}.txt");
        }

        /// <summary>
        /// Метод, реализующий разделение файла с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void SplitToFiles(List<int> series, int threadsNum)
        {
            // Устанавливаем считыватель из файла с будущим отсортированным массивом.
            using StreamReader fileA = new("fileA.txt");
            // Устанавливаем заданное число ссылок в качестве записывателей во временные файлы.
            StreamWriter[] writers = new StreamWriter[threadsNum];
            // Пробегаемся от нуля до числа путей.
            for (int i = 0; i < threadsNum; i++)
                // Устанавливаем путь к файлу для текущего записывателя.
                writers[i] = new($"file{(char)('B' + i)}.txt");
            // Устанавливаем ноль в качестве флага для определения того, куда будет записано текущее число.
            int flag = 0;
            // Устанавливаем ноль в качестве счётчика для отслеживания перехода к следующему файлу.
            int counter = 0;
            // Устанавливаем первую строку из файла с будущим отсортированным массивом в качестве текущего взятого числа.
            string? currentNum = fileA.ReadLine();
            // Устанавливаем вторую строку из файла с будущим отсортированным массивом в качестве следующего взятого числа.
            string? nextNum = fileA.ReadLine();

            // Пока строки в файле с будущим отсортированным массивом не закончились, продолжаем разделение на файла.
            while (currentNum != null)
            {
                // Записываем число в текущий, соответствующий флагу, файл.
                writers[flag].WriteLine(currentNum);
                // Проверяем наличие следующего числа.
                if (nextNum != null)
                {
                    // Инкрементируем счётчик.
                    counter++;
                    // Сравниваем текущий элемент и следующий элемент.
                    if (int.Parse(currentNum) > int.Parse(nextNum))
                    {
                        // Если текущий элемент нестрого больше следующего:
                        // Добавляем в серии число элементов в текущей серии.
                        series.Add(counter);
                        // Обнуляем счётчик.
                        counter = 0;
                        // Переходим к следующему файлу.
                        flag = (flag + 1) % threadsNum;                    
                    }
                }

                // Переходим к следующему числу:
                // Присваиваем текущему значению следующее значение.
                currentNum = nextNum;
                // Считываем следующее число.
                nextNum = fileA.ReadLine();
            }

            // Добавляем в серии число элементов в текущей серии, увеличенное на единицу.
            series.Add(counter + 1);

            // Пробегаемся по записывателям во временные файлы.
            foreach (StreamWriter writer in writers)
                // Закрываем поток.
                writer.Dispose();
        }

        /// <summary>
        /// Метод, реализующий слияние файлов B и C в файл с будущим отсортированным массивом.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void MergePairs(List<int> series, int threadsNum, out StreamReader[] readers)
        {
            // Устанавливаем записыватель в файл с будущим отсортированным массивом.
            using StreamWriter fileA = new("fileA.txt");
            // Устанавливаем заданное число ссылок в качестве считывателей из временных файлов.
            readers = new StreamReader[threadsNum];
            // Пробегаемся от нуля до числа путей.
            for (int i = 0; i < threadsNum; i++)
                // Устанавливаем путь к файлу для текущего считывателя.
                readers[i] = new($"file{(char)('B' + i)}.txt");
            // Устанавливаем нули (по умолчанию) в качестве индексов серий соответствующих считывателей.
            int[] indices = new int[readers.Length];
            // Пробегаемся по массиву индексов.
            for (int i = 0; i < indices.Length; i++)
                // Устанавливаем соответствующий индекс серии.
                indices[i] = i;
            // Устанавливаем заданное число ссылок в качестве элементов из временных файлов.
            string?[] elements = new string?[readers.Length];
            // Пробегаемся по массиву считывателей.
            for (int i = 0; i < readers.Length; i++)
                // Считываем первую строку из каждого временного файла.
                elements[i] = readers[i].ReadLine();
            // Устанавливаем нули (по умолчанию) в качестве счётчиков для файлов для отслеживания перехода к следующему файлу.
            int[] counters = new int[readers.Length];

            // Пока строки в файлах B и C не закончились, продолжаем сортировку.
            while (elements.Any(e => e != null))
            {
                // Устанавливаем истинное значение в качестве флага достижения всеми счётчиками числа элементов соответствующих серий.
                bool allCountersMatch = true;
                // Пробегаемся по массиву счётчиков.
                for (int i = 0; i < counters.Length; i++)
                {
                    // Сравниваем соответствующий счётчик и число элементов серии.
                    if (counters[i] != series[indices[i]])
                    {
                        // Если счётчик не равен числу элементов серии:
                        // Устанавливаем ложное значение у флага.
                        allCountersMatch = false;
                        // Прерываем обход счётчиков.
                        break;
                    }
                }

                // Проверяем значение флага.
                if (allCountersMatch)
                {
                    // Если флаг имеет истинное значение:
                    // Пробегаемся по массиву счётчиков.
                    for (int i = 0; i < counters.Length; i++)
                        // Обнуляем счётчик соответствующего временного файла.
                        counters[i] = 0;
                    for (int i = 0; i < indices.Length; i++)
                        // Инкрементируем индекс серии соответствующего временного файла.
                        indices[i] += threadsNum;
                    // Переходим к следующей итерации.
                    continue;
                }

                // Если флаг имеет ложное значение:
                // Устанавливаем заданное число ссылок в качестве копии элементов из временных файлов.
                string?[] termElements = new string?[elements.Length];
                // Копируем массив элементов.
                Array.Copy(elements, termElements, elements.Length);
                // Пробегаемся от нуля до числа элементов.
                for (int i = 0; i < termElements.Length; i++)
                    // Проверяем, является ли серия последней для временного файла и достиг ли счётчик для этого файла числа элементов текущей серии.
                    if (indices[i] < series.Count && counters[i] != series[indices[i]])
                        // Если счётчик для текущего файла достиг числа итераций, не учитываем элемент текущего файла.
                        termElements[i] = null;

                // Устанавливаем минимальный индекс среди элементов.
                int minIndex = GetMinIndex(elements);
                // Записываем текущее число в файл с будущим отсортированным массивом.
                WriteNextElem(ref elements[minIndex], ref counters[minIndex], fileA, readers[minIndex]);
            }
        }

        /// <summary>
        /// Метод, реализующий запись элемента в файл и считывание следующего элемента.
        /// </summary>
        /// <param name="element">Элемент для записи.</param>
        /// <param name="counter">Счётчик для файла для считывания.</param>
        /// <param name="writer">Записыватель в файл с будущим отсортированным массивом.</param>
        /// <param name="reader">Считыватель из временного файла.</param>
        private static void WriteNextElem(ref string? element, ref int counter, StreamWriter writer, StreamReader reader)
        {
            // Записываем число из файла для считывания в файл с будущим отсортированным массивом.
            writer.WriteLine(element);
            // Считываем следующую строку из файла для считывания.
            element = reader.ReadLine();
            // Инкрементируем счётчик для файла для считывания.
            counter++;
        }

        /// <summary>
        /// Метод, реализующий получение индекса минимального элемента в заданном массиве.
        /// </summary>
        /// <param name="elements">Массив для поиска индекса минимального элемента.</param>
        private static int GetMinIndex(string?[] elements)
        {
            // Устанавливаем -1 в качестве индекса минимального элемента.
            int minIndex = -1;
            // Устанавливаем максимальное целочисленное значение в качестве минимального элемента.
            int minValue = int.MaxValue;

            // Пробегаемся по массиву n раз, где n - длина массива.
            for (int i = 0; i < elements.Length; i++)
            {
                // Проверяем, есть ли элемент по данному индексу.
                if (elements[i] != null)
                {
                    // Если элемент есть:
                    // Конвертируем значение из строки в целое число.
                    int num = int.Parse(elements[i]);
                    // Сравниваем текущий элемент с минимальным.
                    if (num < minValue)
                    {
                        // Если текущий элемент меньше минимального:
                        // Меняем минимальный элемент на текущий.
                        minValue = num;
                        // Меняем индекс минимального элемента на индекс текущего.
                        minIndex = i;
                    }
                }
            }

            // Возвращаем индекс минимального элемента.
            return minIndex;
        }
    }
}
