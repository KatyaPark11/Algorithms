using System.Diagnostics.Metrics;
using System.Reflection.PortableExecutable;
using System.Xml.Linq;

namespace Algorithms.ExternalSortAlgorithms
{
    /// <summary>
    /// Класс, реализующий внешнюю сортировку многопутевым естественным слиянием.
    /// </summary>
    public class ExternalMultiNaturalMergeSort
    {
        /// <summary>
        /// Метод, реализующий внешнюю сортировку многопутевым естественным слиянием.
        /// </summary>
        /// <param name="inputPath">Путь к файлу с массивом для сортировки.</param>
        /// <param name="threadsNum">Число потоков.</param>
        public static void Sort(string inputPath, int threadsNum)
        {
            // Проверяем, допустимо ли введённое количество путей.
            if (threadsNum > 25)
            {
                // Выводим сообщение об ошибке.
                Console.WriteLine("Указано слишком большое число путей. Сортировка не выполнена.");
                // Выходим из метода.
                return;
            }
            // Копируем файл с массивом для сортировки в файл с будущим отсортированным массивом.
            File.Copy(inputPath, "fileA.txt", true);
            // Устанавливаем список серий (отсортированных подмассивов).
            List<int> series = [];
            // Пока после разделения на файлы не останется одна серия, выполняем сортировку.
            while (true)
            {
                series.Clear();
                // Разделяем файл с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
                SplitToFiles(series, threadsNum);
                // Если осталась одна серия, прекращаем сортировку.
                if (series.Count == 1) break;
                // Сливаем временные файлы в файл с будущим отсортированным массивом.
                MergeFiles(series, threadsNum);
            }

            // Пробегаемся от нуля до числа путей.
            for (int i = 0; i < threadsNum; i++)
                // Удаляем текущий временный файл.
                File.Delete($"file{(char)('B' + i)}.txt");
        }

        /// <summary>
        /// Метод, реализующий разделение файла с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void SplitToFiles(List<int> series, int threadsNum)
        {
            // Устанавливаем считыватель из файла с будущим отсортированным массивом.
            using StreamReader fileA = new("fileA.txt");
            // Устанавливаем заданное число ссылок в качестве записывателей во временные файлы.
            StreamWriter[] writers = new StreamWriter[threadsNum];
            // Пробегаемся от нуля до числа путей.
            for (int i = 0; i < threadsNum; i++)
                // Устанавливаем путь к файлу для текущего записывателя.
                writers[i] = new($"file{(char)('B' + i)}.txt");
            // Устанавливаем ноль в качестве флага для определения того, куда будет записано текущее число.
            int flag = 0;
            // Устанавливаем ноль в качестве счётчика для отслеживания перехода к следующему файлу.
            int counter = 0;
            // Устанавливаем первую строку из файла с будущим отсортированным массивом в качестве текущего взятого числа.
            string? curNum = fileA.ReadLine();
            // Устанавливаем вторую строку из файла с будущим отсортированным массивом в качестве следующего взятого числа.
            string? nextNum = fileA.ReadLine();

            // Пока строки в файле с будущим отсортированным массивом не закончились, продолжаем разделение на файла.
            while (curNum != null)
            {
                // Записываем число в текущий, соответствующий флагу, файл.
                writers[flag].WriteLine(curNum);
                // Инкрементируем счётчик.
                counter++;
                // Проверяем наличие следующего числа и сравниваем текущий элемент и следующий элемент.
                if (nextNum != null && int.Parse(curNum) > int.Parse(nextNum))
                {
                    // Если следующее число есть и текущий элемент нестрого больше следующего:
                    // Добавляем в серии число элементов в текущей серии.
                    series.Add(counter);
                    // Обнуляем счётчик.
                    counter = 0;
                    // Переходим к следующему файлу.
                    flag = (flag + 1) % threadsNum;
                }

                // Если не выполняются оба условия:
                // Присваиваем текущему значению следующее значение.
                curNum = nextNum;
                // Считываем следующее число.
                nextNum = fileA.ReadLine();
            }
            // Добавляем в серии число элементов в текущей серии, увеличенное на единицу.
            series.Add(counter);

            // Пробегаемся по записывателям во временные файлы.
            foreach (StreamWriter writer in writers)
                // Закрываем поток.
                writer.Dispose();
        }

        /// <summary>
        /// Метод, реализующий слияние временных файлов в файл с будущим отсортированным массивом.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void MergeFiles(List<int> series, int threadsNum)
        {
            // Устанавливаем записыватель в файл с будущим отсортированным массивом.
            using StreamWriter fileA = new("fileA.txt");
            // Устанавливаем заданное число ссылок в качестве считывателей из временных файлов.
            StreamReader[] readers = new StreamReader[threadsNum];
            // Пробегаемся от нуля до числа потоков.
            for (int i = 0; i < threadsNum; i++)
                // Устанавливаем путь к файлу для текущего считывателя.
                readers[i] = new($"file{(char)('B' + i)}.txt");
            // Устанавливаем нули (по умолчанию) в качестве индексов серий соответствующих считывателей.
            int[] indices = new int[threadsNum];
            // Пробегаемся от нуля до числа потоков.
            for (int i = 0; i < threadsNum; i++)
                // Устанавливаем соответствующий индекс серии.
                indices[i] = i;
            // Устанавливаем заданное число ссылок в качестве элементов из временных файлов.
            string?[] elements = new string?[threadsNum];
            // Пробегаемся от нуля до числа потоков.
            for (int i = 0; i < threadsNum; i++)
                // Считываем первую строку из каждого временного файла.
                elements[i] = readers[i].ReadLine();
            // Устанавливаем нули (по умолчанию) в качестве счётчиков для файлов для отслеживания перехода к следующему файлу.
            int[] counters = new int[threadsNum];

            // Пока строки во временных файлах не закончились, продолжаем сортировку.
            while (elements.Any(e => e != null))
            {
                // Если флаг имеет ложное значение:
                // Устанавливаем заданное число ссылок в качестве копии элементов из временных файлов.
                string?[] tempElements = new string?[elements.Length];
                // Копируем массив элементов.
                Array.Copy(elements, tempElements, elements.Length);
                // Пробегаемся от нуля до числа потоков.
                for (int i = 0; i < threadsNum; i++)
                    // Проверяем, является ли серия последней для временного файла и достиг ли счётчик для этого файла числа элементов текущей серии.
                    if (indices[i] >= series.Count || counters[i] == series[indices[i]])
                        // Если счётчик для текущего файла достиг числа итераций, не учитываем элемент текущего файла.
                        tempElements[i] = null;
                // Устанавливаем минимальный индекс среди элементов.
                int minIndex = GetMinIndex(tempElements);
                // Записываем число из временного файла в файл с будущим отсортированным массивом.
                fileA.WriteLine(elements[minIndex]);
                // Считываем следующую строку из временного файла.
                elements[minIndex] = readers[minIndex].ReadLine();
                // Инкрементируем счётчик для временного файла.
                counters[minIndex]++;

                // Устанавливаем ложное значение в качестве флага перехода к следующей итерации.
                bool isNextIter = false;
                // Пробегаемся от нуля до числа потоков.
                for (int i = 0; i < threadsNum; i++)
                {
                    // Проверяем, является ли серия последней для временного файла дошёл ли счётчик до конца серии текущего файла.
                    if (indices[i] < series.Count && counters[i] != series[indices[i]])
                    {
                        // Если счётчик не дошёл до конца серии текущего файла:
                        // Устанавливаем истинное значение для флага.
                        isNextIter = true;
                        // Прерываем обход массива счётчиков.
                        break;
                    }
                }
                // Если флаг имеет истинное значение, переходим к следующей итерации.
                if (isNextIter) continue;
                    
                // Если флаг имеет ложное значение:
                // Пробегаемся от нуля до числа потоков.
                for (int i = 0; i < threadsNum; i++)
                {
                    // Обнуляем счётчик соответствующего временного файла.
                    counters[i] = 0;
                    // Инкрементируем индекс серии соответствующего временного файла.
                    indices[i] += threadsNum;
                }
            }

            // Пробегаемся по считывателям из временных файлов.
            foreach (var reader in readers)
                // Закрываем поток.
                reader.Dispose();
        }

        /// <summary>
        /// Метод, реализующий получение индекса минимального элемента в заданном массиве.
        /// </summary>
        /// <param name="elements">Массив для поиска индекса минимального элемента.</param>
        private static int GetMinIndex(string?[] elements)
        {
            // Устанавливаем -1 в качестве индекса минимального элемента.
            int minIndex = -1;
            // Устанавливаем максимальное целочисленное значение в качестве минимального элемента.
            int minValue = int.MaxValue;

            // Пробегаемся по массиву n раз, где n - длина массива.
            for (int i = 0; i < elements.Length; i++)
            {
                // Проверяем, есть ли элемент по данному индексу.
                if (elements[i] != null)
                {
                    // Если элемент есть:
                    // Конвертируем значение из строки в целое число.
                    int num = int.Parse(elements[i]);
                    // Сравниваем текущий элемент с минимальным.
                    if (num < minValue)
                    {
                        // Если текущий элемент меньше минимального:
                        // Меняем минимальный элемент на текущий.
                        minValue = num;
                        // Меняем индекс минимального элемента на индекс текущего.
                        minIndex = i;
                    }
                }
            }

            // Возвращаем индекс минимального элемента.
            return minIndex;
        }
    }
}
