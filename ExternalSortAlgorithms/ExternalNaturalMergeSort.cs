namespace Algorithms.ExternalSortAlgorithms
{
    /// <summary>
    /// Класс, реализующий внешнюю сортировку естественным слиянием.
    /// </summary>
    public class ExternalNaturalMergeSort
    {
        /// <summary>
        /// Метод, реализующий внешнюю сортировку естественным слиянием.
        /// </summary>
        /// <param name="inputPath">Путь к файлу с массивом для сортировки.</param>
        public static void Sort(string inputPath)
        {
            // Копируем файл с массивом для сортировки в файл с будущим отсортированным массивом.
            File.Copy(inputPath, "fileA.txt", true);
            // Устанавливаем список серий (отсортированных подмассивов).
            List<int> series = [];
            // Пока после разделения на файлы не останется одна серия, выполняем сортировку.
            while (true)
            {
                series.Clear();
                // Разделяем файл с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
                SplitToFiles(series);
                // Если осталась одна серия, прекращаем сортировку.
                if (series.Count == 1) break;
                // Сливаем временные файлы в файл с будущим отсортированным массивом.
                MergePairs(series);
            }
            // Удаляем временный файл B.
            File.Delete("fileB.txt");
            // Удаляем временный файл C.
            File.Delete("fileC.txt");
        }

        /// <summary>
        /// Метод, реализующий разделение файла с будущим отсортированным массивом в соответствии с отсортированными подмассивами.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void SplitToFiles(List<int> series)
        {
            // Устанавливаем считыватель из файла с будущим отсортированным массивом.
            using StreamReader fileA = new("fileA.txt");
            // Устанавливаем записыватель во временный файл B.
            using StreamWriter fileB = new("fileB.txt");
            // Устанавливаем записыватель во временный файл C.
            using StreamWriter fileC = new("fileC.txt");
            // Устанавливаем первую строку из файла с будущим отсортированным массивом в качестве текущего взятого числа.
            string? currentNum = fileA.ReadLine();
            // Устанавливаем вторую строку из файла с будущим отсортированным массивом в качестве следующего взятого числа.
            string? nextNum = fileA.ReadLine();
            // Устанавливаем истинное значение в качестве флага для определения того, куда будет записано текущее число.
            bool flag = true;
            // Устанавливаем ноль в качестве счётчика числа элементов в серии.
            int counter = 0;

            // Пока строки в файле с будущим отсортированным массивом не закончились, продолжаем разделение на файла.
            while (currentNum != null)
            {
                // Устанавливаем значение флага текущего числа в качестве флага для определения того, куда будет записано следующее число.
                bool tempFlag = flag;
                // Проверяем наличие следующего числа.
                if (nextNum != null)
                {// Инкрементируем счётчик.
                    counter++;
                    // Сравниваем текущий элемент и следующий элемент.
                    if (int.Parse(currentNum) > int.Parse(nextNum))
                    {
                        // Если текущий элемент нестрого больше следующего:
                        // Инвертируем флаг следующего элемента.
                        tempFlag = !tempFlag;
                        // Добавляем в серии число элементов в текущей серии.
                        series.Add(counter);
                        // Обнуляем счётчик.
                        counter = 0;
                    }
                }

                // Проверяем значение флага.
                if (flag)
                    // Если флаг имеет истинное значение, записываем текущее число в файл B.
                    fileB.WriteLine(currentNum);
                else
                    // Если флаг имеет ложное значение, записываем текущее число в файл C.
                    fileC.WriteLine(currentNum);

                // Переходим к следующему числу:
                // Присваиваем текущему значению следующее значение.
                currentNum = nextNum;
                // Считываем следующее число.
                nextNum = fileA.ReadLine();
                // Присваиваем значение флага следующего числа значению флага текущего числа.
                flag = tempFlag;
            }

            // Добавляем в серии число элементов в текущей серии, увеличенное на единицу.
            series.Add(counter + 1);
        }

        /// <summary>
        /// Метод, реализующий слияние файлов B и C в файл с будущим отсортированным массивом.
        /// </summary>
        /// <param name="series">Список серий (отсортированных подмассивов).</param>
        private static void MergePairs(List<int> series)
        {
            // Устанавливаем записыватель в файл с будущим отсортированным массивом.
            using StreamWriter fileA = new("fileA.txt");
            // Устанавливаем считыватель из временного файла B.
            using StreamReader fileB = new("fileB.txt");
            // Устанавливаем считыватель из временного файла C.
            using StreamReader fileC = new("fileC.txt");
            // Устанавливаем ноль в качестве индекса серии файла B.
            int indexB = 0;
            // Устанавливаем единицу в качестве индекса серии файла C.
            int indexC = 1;
            // Устанавливаем первую строку из файла B в качестве текущего взятого из него числа.
            string? elementB = fileB.ReadLine();
            // Устанавливаем первую строку из файла C в качестве текущего взятого из него числа.
            string? elementC = fileC.ReadLine();
            // Устанавливаем ноль в качестве счётчика для файла B для отслеживания перехода к следующему файлу.
            int counterB = 0;
            // Устанавливаем ноль в качестве счётчика для файла C для отслеживания перехода к следующему файлу.
            int counterC = 0;

            // Пока строки в файлах B и C не закончились, продолжаем сортировку.
            while (elementB != null || elementC != null)
            {
                // Проверяем, достиг ли счётчик для файлов B и C числа элементов соответствующих серий.
                if (counterB == series[indexB] && counterC == series[indexC])
                {
                    // Обнуляем счётчик для файла B.
                    counterB = 0;
                    // Обнуляем счётчик для файла C.
                    counterC = 0;
                    // Инкрементируем индекс серии для файла B.
                    indexB += 2;
                    // Инкрементируем индекс серии для файла C.
                    indexC += 2;
                    // Переходим к следующей итерации.
                    continue;
                }
                // Иначе проверяем, является ли серия последней для файла B и достиг ли счётчик для файла B числа элементов текущей серии.
                else if (indexB == series.Count || counterB == series[indexB])
                {
                    // Если хотя бы одно утверждение верно:
                    // Берём число из файла C.
                    WriteNextElem(ref elementC, ref counterC, fileA, fileC);
                    // Переходим к следующей итерации.
                    continue;
                }
                // Иначе проверяем, является ли серия последней для файла C и достиг ли счётчик для файла C числа элементов текущей серии.
                else if (indexC == series.Count || counterC == series[indexC])
                {
                    // Если хотя бы одно утверждение верно:
                    // Берём число из файла B.
                    WriteNextElem(ref elementB, ref counterB, fileA, fileB);
                    // Переходим к следующей итерации.
                    continue;
                }

                // Сравниваем элемент из файла B и из файла C.
                if (int.Parse(elementB) < int.Parse(elementC))
                    // Если элемент из файла B меньше элемента из файла C, берём число из файла B.
                    WriteNextElem(ref elementB, ref counterB, fileA, fileB);
                else
                    // Если элемент из файла B больше элемента из файла C, берём число из файла C.
                    WriteNextElem(ref elementC, ref counterC, fileA, fileC);
            }
        }

        /// <summary>
        /// Метод, реализующий запись элемента в файл и считывание следующего элемента.
        /// </summary>
        /// <param name="element">Элемент для записи.</param>
        /// <param name="counter">Счётчик для файла для считывания.</param>
        /// <param name="writer">Записыватель в файл с будущим отсортированным массивом.</param>
        /// <param name="reader">Считыватель из временного файла.</param>
        private static void WriteNextElem(ref string? element, ref int counter, StreamWriter writer, StreamReader reader)
        {
            // Записываем число из файла для считывания в файл с будущим отсортированным массивом.
            writer.WriteLine(element);
            // Считываем следующую строку из файла для считывания.
            element = reader.ReadLine();
            // Инкрементируем счётчик для файла для считывания.
            counter++;
        }
    }
}
