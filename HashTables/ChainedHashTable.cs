using Algorithms.DinamicStructures;

namespace Algorithms.HashTables
{
    /// <summary>
    /// Класс, реализующий хэш-таблицу с методом разрешения коллизий с помощью цепочек.
    /// </summary>
    public class ChainedHashTable
    {
        /// <summary>
        /// Размер таблицы.
        /// </summary>
        public int Size;
        /// <summary>
        /// Цепочки, хранимые в таблице.
        /// </summary>
        private readonly DinamicStructures.LinkedList<int>[] hashTable;
        
        /// <summary>
        /// Конструктор класса.
        /// </summary>
        /// <param name="size">Размер хэш-таблицы.</param>
        public ChainedHashTable(int size)
        {
            // Устанавливаем указанное значение в качестве размера таблицы.
            Size = size;
            // Устанавливаем массив со значениями по умолчанию в качестве цепочек хэш-таблицы.
            hashTable = new DinamicStructures.LinkedList<int>[size];
            // Пробегаемся по массиву n раз, где n - размер массива.
            for (int i = 0; i < hashTable.Length; i++) 
                // Устанавливаем пустой список в качестве текущей цепочки хэш-таблицы.
                hashTable[i] = new();
        }

        /// <summary>
        /// Метод, реализующий вставку нового элемента в таблицу.
        /// </summary>
        /// <param name="key">Вставляемый элемент.</param>
        public void Insert(int key)
        {
            // Устанавливаем хэш, полученный методом деления, в качестве хэша вставляемого элемента.
            int hash = key % Size;
            // Проверяем, есть ли вставляемый элемент в таблице.
            if (Contains(key) == null)
                // Если элемента нет, то добавляем его в начало цепочки.
                hashTable[hash].AddHead(key);
        }

        /// <summary>
        /// Метод, реализующий поиск элемента в хэш-таблице.
        /// </summary>
        /// <param name="key">Искомый элемент.</param>
        /// <returns>Индекс (хэш) искомого элемента или null, если элемент не найден.</returns>
        public int? Contains(int key)
        {
            // Устанавливаем хэш, полученный методом деления, в качестве хэша искомого элемента.
            int hash = key % Size;
            // Устанавливаем первый элемент цепочки в качестве текущего.
            Node<int>? curNode = hashTable[hash].Head;
            // Пока элементы в списке не закончились, продолжаем поиск элемента. 
            while (curNode != null)
            {
                // Если текущий элемент искомый, то возвращаем его хэш.
                if (curNode.Value == key) return hash;
                // Иначе переходим к следующему элементу.
                curNode = curNode.Next;
            }
            // При отсутствии искомого элемента в списке, возвращаем пустую ссылку.
            return null;
        }

        /// <summary>
        /// Метод, реализующий удаление элемента из хэш-таблицы.
        /// </summary>
        /// <param name="key">Удаляемый элемент.</param>
        public void Remove(int key)
        {
            // Устанавливаем хэш, полученный методом деления, в качестве хэша удаляемого элемента.
            int hash = key % Size;
            // Устанавливаем первый элемент цепочки в качестве текущего.
            Node<int>? curNode = hashTable[hash].Head;
            // Если в хэш-таблице нет элементов, выходим из метода.
            if (curNode == null) return;
            // Проверяем, является ли текущий элемент первым в цепочке:
            if (curNode.Value == key)
            {
                // Если удаляемый элемент является первым в цепочке:
                // Удаляем заданный элемент.
                hashTable[hash].RemoveHead();
                // Выходим из метода.
                return;
            }
            // Иначе проверяем, является ли удаляемый элемент последним в цепочке:
            else if (hashTable[hash].Tail.Value == key)
            {
                // Если удаляемый элемент является последним в цепочке:
                // Удаляем заданный элемент.
                hashTable[hash].RemoveTail();
                // Выходим из метода.
                return;
            }

            // Если удаляемый элемент не является первым или последним в цепочке, то переходим к следующему.
            curNode = curNode.Next;
            // Пока элементы в списке не закончились, продолжаем поиск элемента. 
            while (curNode != null)
            {
                // Сравниваем значение текущего элемента со значением удаляемого.
                if (curNode.Value == key)
                {
                    // Если текущий элемент равен удаляемому:
                    // Меняем ссылку на следующий элемент у предыдущего для текущего на следующий для текущего. 
                    curNode.Previous.Next = curNode.Next;
                    // Меняем ссылку на предыдущий элемент у следующего для текущего на предыдущий для текущего. 
                    curNode.Next.Previous = curNode.Previous;
                    // Выходим из метода.
                    return;
                }
                // Если текущий элемент не равен удаляемому, то переходим к следующему.
                curNode = curNode.Next;
            }
        }
    }
}
