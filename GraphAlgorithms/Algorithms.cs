namespace Algorithms.GraphAlgorithms
{
    /// <summary>
    /// Класс, реализующий алгоритмы для работы с графом.
    /// </summary>
    public static class Algorithms
    {
        /// <summary>
        /// Метод, реализующий поиск минимального остовного дерева через алгоритм Крускала.
        /// </summary>
        /// <param name="lines">Список линий (рёбер) графа.</param>
        /// <returns>Список с минимальным остовным деревом.</returns>
        public static List<Line> Kruskal(List<Line> lines)
        {
            // Сортируем линии по весу.
            lines.Sort((x, y) => x.Weight.CompareTo(y.Weight));
            // Устанавливаем пустой список в качестве списка с будущим минимальным остовным деревом.
            List<Line> minimumSpanningTree = [];
            // Устанавливаем ноль в качестве счётчика точек.
            int count = 0;
            // Пробегаемся по массиву линий.
            foreach (Line line in lines)
            {
                // Сравниваем имя начальной точки текущей линии (ребра) с нулём.
                if (line.Points.Item1.Name == 0)
                    // Если имя начальной точки текущей линии (ребра) равно нулю, устанавливаем для неё новое имя и инкрементируем счётчик.
                    line.Points.Item1.Name = 1 + count++;
                // Сравниваем имя конечной точки текущей линии (ребра) с нулём.
                if (line.Points.Item2.Name == 0)
                    // Если имя конечной точки текущей линии (ребра) равно нулю, устанавливаем для неё новое имя и инкрементируем счётчик.
                    line.Points.Item2.Name = 1 + count++;
            }
            // Устанавливаем массив со значениями по умолчанию в качестве массива, который будет хранить корневые вершины для каждой вершины графа.
            int[] parent = new int[count];
            // Пробегаемся по массиву от единицы до числа точек включительно.
            for (int i = 1; i <= count; i++)
                // Устанавливаем вершину графа свою корневую вершину.
                parent[i - 1] = i;

            // Пробегаемся по каждой линии (ребру) в отсортированном порядке.
            foreach (Line line in lines)
            {
                // Находим корневую вершину для начальной точки линии (ребра).
                int rootStart = FindRoot(line.Points.Item1.Name, parent);
                // Находим корневую вершину для конечной точки линии (ребра).
                int rootEnd = FindRoot(line.Points.Item2.Name, parent);

                // Сравниваем корневую вершину для начальной точки и для конечной точки.
                if (rootStart != rootEnd)
                {
                    // Если корневая вершина для начальной точки равна корневой вершине для конечной:
                    // Добавляем текущую линию (ребро) в список с будущим минимальным остовным деревом.
                    minimumSpanningTree.Add(line);
                    // Меняем корневую вершину для начальной точки на корневую вершину для конечной.
                    parent[rootStart - 1] = rootEnd;
                }
            }

            // Возвращаем список с минимальным остовным деревом.
            return minimumSpanningTree;
        }

        /// <summary>
        /// Метод, реализующий поиск корневой вершины.
        /// </summary>
        /// <param name="vertex">Имя точки (вершины).</param>
        /// <param name="parent">Массив корневых вершин точек (вершин).</param>
        /// <returns>Имя корневой точки (вершины) указанной точки (вершины).</returns>
        static int FindRoot(int vertex, int[] parent)
        {
            // Сравниваем корневую вершину точки с самой точкой.
            if (parent[vertex - 1] != vertex)
                // Если точка не является корневой, ищем корневую вершину её корневой точки.
                vertex = FindRoot(parent[vertex - 1], parent);
            // Если точка является корневой, то возвращаем корневую вершину для указанной точки.
            return vertex;
        }

        /// <summary>
        /// Метод, реализующий поиск минимального остовного дерева через алгоритм Прима.
        /// </summary>
        /// <param name="points">Список точек графа.</param>
        /// <returns>Список с минимальным остовным деревом.</returns>
        public static List<Line> Prim(List<Point> points)
        {
            // Устанавливаем пустой список в качестве списка с будущим минимальным остовным деревом.
            List<Line> minimumSpanningTree = [];
            // Устанавливаем множество с первой точкой в качестве множества посещенных точек.
            HashSet<Point> visitedPoints = [ points[0] ];

            // Пока число посещённых точек не достигло числа всех точек, продолжаем формирование минимального остовного дерева.
            while (visitedPoints.Count < points.Count)
            {
                // Устанавливаем пустую ссылку в качестве минимальной линии (ребра).
                Line? minWeightLine = null;
                // Пробегаемся по посещённым точкам.
                foreach (Point point in visitedPoints)
                {
                    // Пробегаемся по линиям, связанным с текущей точкой.
                    foreach (Line line in point.LinkedLines)
                    {
                        // Если начальная и конечная точки являются посещёнными, переходим к следующей итерации.
                        if (visitedPoints.Contains(line.Points.Item1) && visitedPoints.Contains(line.Points.Item2)) continue;
                        // Если нет текущей минимальной линии (ребра) и вес текущей линии (ребра) нестрого больше текущей минимальной линии (ребра), то переходим к следующей итерации.
                        if (minWeightLine != null && line.Weight >= minWeightLine.Weight) continue;
                        // Если все условия выше ложны, устанавливаем текущую линию (ребро) в качестве текущей минимальной линии (ребра).
                        minWeightLine = line;
                    }
                }

                // Добавляем найденное ребро в список с будущим минимальным остовным деревом.
                minimumSpanningTree.Add(minWeightLine);
                // Добавляем первую точку линии (ребра) во множество посещенных точек.
                visitedPoints.Add(minWeightLine.Points.Item1);
                // Добавляем вторую точку линии (ребра) во множество посещенных точек.
                visitedPoints.Add(minWeightLine.Points.Item2);
            }

            // Возвращаем список с минимальным остовным деревом.
            return minimumSpanningTree;
        }

        /// <summary>
        /// Метод, реализующий начало рекурсивного обхода графа в глубину.
        /// </summary>
        /// <param name="curPoint">Текущая точка.</param>
        /// <param name="points">Список точек графа.</param>
        public static void StartRecDFS(Point curPoint, List<Point> points)
        {
            // Пробегаемся по списку точек.
            foreach (Point point in points)
                // Объявляем их непосещёнными.
                point.IsVisited = false;
            // Запускаем метод, реализующий рекурсивный обход графа в глубину.
            RecursiveDFS(curPoint);
        }

        /// <summary>
        /// Метод, реализующий рекурсивный обход графа в глубину.
        /// </summary>
        /// <param name="curPoint">Текущая точка.</param>
        public static void RecursiveDFS(Point curPoint)
        {
            // Если текущая точка не задана, прекращаем обход графа.
            if (curPoint == null) return;
            // Выводим текущую точку.
            Console.WriteLine(curPoint.Name);
            // Помечаем текущую точку как посещенную.
            curPoint.IsVisited = true;

            // Пробегаемся по линиям, связанным с текущей точкой.
            foreach (Line line in curPoint.LinkedLines)
            {
                // Объявляем следующую после текущей точку.
                Point nextPoint;
                // Сравниваем начальную точку текущей линии с текущей точкой.
                if (line.Points.Item1 == curPoint)
                    // Если начальная точка текущей линии равна текущей точке, то устанавливаем конечную точку текущей линии в качестве следующей после текущей.
                    nextPoint = line.Points.Item2;
                else
                    // Если начальная точка текущей линии не равна текущей точке, то устанавливаем её в качестве следующей после текущей.
                    nextPoint = line.Points.Item1;

                // Проверяем, посещена ли следующая после текущей точка.
                if (!nextPoint.IsVisited)
                    // Если точка не посещена, продолжаем обход графа.
                    RecursiveDFS(nextPoint);
            }
        }

        /// <summary>
        /// Метод, реализующий обход графа в глубину через стек.
        /// </summary>
        /// <param name="startPoint">Начальная точка.</param>
        /// <param name="points">Список точек графа.</param>
        public static void StackDFS(Point startPoint, List<Point> points)
        {
            // Если начальная точка не задана, прекращаем обход графа.
            if (startPoint == null) return;
            // Пробегаемся по списку точек.
            foreach (Point point in points)
                // Объявляем их непосещёнными.
                point.IsVisited = false;
            // Устанавливаем пустой стек в качестве стека для записи точек обхода графа.
            DinamicStructures.Stack<Point> stack = new();
            // Добавляем начальную точку в стек.
            stack.Push(startPoint);
            // Помечаем начальную точку как посещенную.
            startPoint.IsVisited = true;

            // Пока элементы в стеке не закончились, продолжаем обход графа.
            while (stack.elements.Head != null)
            {
                // Устанавливаем извлечённый с вершины стека элемент в качестве текущей точки.
                Point curPoint = stack.Pop();
                // Выводим текущую точку.
                Console.WriteLine(curPoint.Name);

                // Пробегаемся по линиям, связанным с текущей точкой.
                foreach (Line line in curPoint.LinkedLines)
                {
                    // Объявляем следующую после текущей точку.
                    Point nextPoint;
                    // Сравниваем начальную точку текущей линии с текущей точкой.
                    if (line.Points.Item1 == curPoint)
                        // Если начальная точка текущей линии равна текущей точке, то устанавливаем конечную точку текущей линии в качестве следующей после текущей.
                        nextPoint = line.Points.Item2;
                    else
                        // Если начальная точка текущей линии не равна текущей точке, то устанавливаем её в качестве следующей после текущей.
                        nextPoint = line.Points.Item1;

                    // Проверяем, посещена ли следующая после текущей точка.
                    if (!nextPoint.IsVisited)
                    {
                        // Если следующая после текущей точка не посещена:
                        // Добавляем следующую после текущей точку в стек.
                        stack.Push(nextPoint);
                        // Помечаем следующую после текущей точку как посещённую.
                        nextPoint.IsVisited = true;
                    }
                }
            }
        }

        /// <summary>
        /// Метод, реализующий обход графа в ширину.
        /// </summary>
        /// <param name="startPoint">Начальная точка.</param>
        /// <param name="points">Список точек графа.</param>
        public static void BFS(Point startPoint, List<Point> points)
        {
            // Если начальная точка не задана, прекращаем обход графа.
            if (startPoint == null) return;
            // Пробегаемся по списку точек.
            foreach (Point point in points)
                // Объявляем их непосещёнными.
                point.IsVisited = false;
            // Устанавливаем пустую очередь в качестве очереди для записи точек обхода графа.
            DinamicStructures.Queue<Point> queue = new();
            // Добавляем начальную точку в очередь.
            queue.Enqueue(startPoint);
            // Помечаем начальную точку как посещенную.
            startPoint.IsVisited = true;

            // Пока элементы в очереди не закончились, продолжаем обход графа.
            while (queue.elements.Tail != null)
            {
                // Устанавливаем извлечённый с начала очереди элемент в качестве текущей точки.
                Point curPoint = queue.Dequeue();
                // Выводим текущую точку.
                Console.WriteLine(curPoint.Name);

                // Пробегаемся по линиям, связанным с текущей точкой.
                foreach (Line line in curPoint.LinkedLines)
                {
                    // Объявляем следующую после текущей точку.
                    Point nextPoint;
                    // Сравниваем начальную точку текущей линии с текущей точкой.
                    if (line.Points.Item1 == curPoint)
                        // Если начальная точка текущей линии равна текущей точке, то устанавливаем конечную точку текущей линии в качестве следующей после текущей.
                        nextPoint = line.Points.Item2;
                    else
                        // Если начальная точка текущей линии не равна текущей точке, то устанавливаем её в качестве следующей после текущей.
                        nextPoint = line.Points.Item1;

                    // Проверяем, посещена ли следующая после текущей точка.
                    if (!nextPoint.IsVisited)
                    {
                        // Если следующая после текущей точка не посещена:
                        // Добавляем следующую после текущей точку в очередь.
                        queue.Enqueue(nextPoint);
                        // Помечаем следующую после текущей точку как посещённую.
                        nextPoint.IsVisited = true;
                    }
                }
            }
        }

        /// <summary>
        /// Метод, реализующий поиск кратчайшего пути через алгоритм Дейкстры.
        /// </summary>
        /// <param name="points">Список точек графа.</param>
        /// <param name="startPoint">Начальная точка.</param>
        /// <returns>Словарь, в котором каждой точке соответствует минимальное расстояние до неё от начальной точкой.</returns>
        public static Dictionary<Point, int> Dijkstra(List<Point> points, Point startPoint)
        {
            // Пробегаемся по списку точек.
            foreach (Point point in points)
                // Объявляем их непосещёнными.
                point.IsVisited = false;
            // Устанавливаем пустой словарь в качестве словаря точек и расстояний от начальной точки до них.
            Dictionary<Point, int> distances = [];
            // Пробегаемся по точкам графа.
            foreach (var point in points)
                // Заменяем расстояние до точки на "бесконечность".
                distances[point] = int.MaxValue;
            // Изменяем расстояние до начальной точки на ноль.
            distances[startPoint] = 0;

            // Пока все точки не посещены, продолжаем поиск минимальных расстояний от начальной точки.
            while (true)
            {
                // Устанавливаем пустую ссылку в качестве текущей точки.
                Point? curPoint = null;
                // Устанавливаем максимальное значение в качестве текущего минимального расстояния от начальной точки до текущей точки.
                int minDistance = int.MaxValue;

                // Проходимся по точкам.
                foreach (Point point in points)
                {
                    // Проверяем, посещена ли точка и меньше ли расстояние до текущей точки внутреннего цикла, чем до текущей точки внешнего.
                    if (!point.IsVisited && distances[point] < minDistance)
                    {
                        // Если оба условия истины:
                        // Меняем минимальное расстояние до текущей точки внешнего цикла на расстояние до текущей точки внутреннего.
                        minDistance = distances[point];
                        // Переходим к точке с меньшим расстоянием.
                        curPoint = point;
                    }
                }

                // Если все точки посещены, прекращаем поиск минимальных расстояний от начальной точки.
                if (curPoint == null) break;

                // Если не все точки посещены:
                // Помечаем текущую точку как посещенную.
                curPoint.IsVisited = true;

                // Пробегаемся по линиям, связанным с текущей точкой.
                foreach (Line line in curPoint.LinkedLines)
                {
                    // Объявляем следующую после текущей точку.
                    Point nextPoint;
                    // Сравниваем начальную точку текущей линии с текущей точкой.
                    if (line.Points.Item1 == curPoint)
                        // Если начальная точка текущей линии равна текущей точке, то устанавливаем конечную точку текущей линии в качестве следующей после текущей.
                        nextPoint = line.Points.Item2;
                    else
                        // Если начальная точка текущей линии не равна текущей точке, то устанавливаем её в качестве следующей после текущей.
                        nextPoint = line.Points.Item1;

                    // Устанавливаем сумму расстояния до текущей точки и веса текущей линии в качестве расстояния до следующей после текущей точки через текущую линию.
                    int distanceToNext = distances[curPoint] + line.Weight;
                    // Сравниваем расстояние до следующей после текущей точки через текущую линию с уже установленным.
                    if (distanceToNext < distances[nextPoint])
                        // Если расстояние до следующей после текущей точки через текущую линию меньше уже установленного, заменяем на него предыдущее значение.
                        distances[nextPoint] = distanceToNext;
                }
            }
            // Возвращаем словарь, в котором каждой точке соответствует минимальное расстояние до неё от начальной точкой.
            return distances;
        }
    }
}


